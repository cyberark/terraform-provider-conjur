# CyberArk Secrets Manager Provider

[![GitHub release](https://img.shields.io/github/release/cyberark/terraform-provider-conjur.svg)](https://github.com/cyberark/terraform-provider-conjur/releases/latest)

This provider manages authentication with CyberArk Secrets Manager, allowing Terraform to access and manage various Secrets Manager resources.

The provider can access the following Secrets Manager resources as data sources:
- [conjur_secret](./data-sources/secret.md) (also available as [ephemeral resource](./ephemeral-resources/secret.md))
- [conjur_certificate_issue](./data-sources/certificate_issue.md) (requires Secrets Manager Saas with Certificate Manager integration)
- [conjur_certificate_sign](./data-sources/certificate_sign.md) (requires Secrets Manager Saas with Certificate Manager integration)

The provider can also manage the following Secrets Manager resources:
- [conjur_authenticator](./resources/authenticator.md)
- [conjur_branch](./resources/branch.md)
- [conjur_host](./resources/host.md) (SaaS only)
- [conjur_group](./resources/group.md)
- [conjur_secret](./resources/secret.md) (SaaS only)
- [conjur_membership](./resources/membership.md)
- [conjur_permission](./resources/permission.md)

## Example Usage

### Using provider configuration attributes
```terraform
terraform {
  required_providers {
    conjur = {
      source  = "cyberark/conjur"
    }
  }
}

provider "conjur" {
  appliance_url = var.conjur_appliance_url
  account       = var.conjur_account
  authn_type    = var.conjur_authn_type
  login         = var.conjur_authn_login
  api_key       = var.conjur_api_key
  ssl_cert      = var.conjur_ssl_cert
}
```

### Using environment variables
Alternatively, the Terraform provider can read configuration from environment variables instead of provider attributes.
For example:
```sh
export CONJUR_APPLIANCE_URL="https://conjur-server"
export CONJUR_ACCOUNT="myorg"
export CONJUR_AUTHN_LOGIN="admin"
export CONJUR_AUTHN_API_KEY="3ahcddy39rcxzh3ggac4cwk3j2r8pqwdg33059y835ys2rh2kzs2a"
export CONJUR_CERT_FILE="/etc/conjur.pem"
```
In this scenario, the provider block can be left empty:
```terraform
terraform {
  required_providers {
    conjur = {
      source  = "cyberark/conjur"
    }
  }
}

provider "conjur" {}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `account` (String) CyberArk Secrets Manager account
- `api_key` (String) CyberArk Secrets Manager API key
- `appliance_url` (String) CyberArk Secrets Manager endpoint URL
- `authn_jwt_token` (String) Authn JWT Token
- `authn_type` (String) CyberArk Secrets Manager Authentication Type
- `client_id` (String) Azure client ID for user assigned managed identity
- `host_id` (String) CyberArk Secrets Manager host ID
- `login` (String) CyberArk Secrets Manager login
- `service_id` (String) CyberArk Secrets Manager service ID
- `ssl_cert` (String) Content of CyberArk Secrets Manager public SSL certificate
- `ssl_cert_path` (String) Path to CyberArk Secrets Manager public SSL certificate

## Best Practices
When working with resources it is important to consider relationships which may affect the ability of the provider to manage many
resources simultaneously.  

Consider the following limitations:
- Nothing may be added to a branch before it is created or after it has been destroyed (error: `422 Unprocessable Entity`)
- Referenced role(s) and resource(s) must exist prior to applying memberships/permissions (error: `422 Unprocessable Entity`)
- Secrets Manager does not support simultaneous policy loading under the same branch (error: `409 Conflict`)

There are a few options to mitigate potential issues with concurrent resource management:  
- Use explicit dependencies to define resource creation order via `depends_on` attribute
    - For example, a conjur_group_membership resource depends on the conjur_host and conjur_group resources being created first
- Use implicit dependencies by referencing resource attributes
    - For example, reference a conjur_host and a conjur_group `name` attribute when creating a conjur_group_membership definition
- Use Terraform's concurrency control flag `-parallelism=1` flag when running `terraform` CLI commands
    - This ensures Terraform only makes one API call at a time. Note: there may still be issues with the order of requests with
      this method alone.
- If all else fails, simply re-running `terraform apply` multiple times can iteratively resolve issues as resources are created

Similarly, there are considerations to be made when working with existing resources:
- Terraform-managed resources which are modified outside Terraform (for example, via CLI/API requests or loading policy) can cause state-drift.
  The provider will attempt to reconcile the state, but this may not always be possible.
- Replacing or deleting a policy branch will also delete all resources under that branch. This could cause unexpected behavior if other systems
  use the branch, or other Terraform-managed resources still depend on the branch.
- Replacing or deleting any role or resource referenced by a membership/permission will also delete the membership or permission. This could
  cause unexpected behavior if other systems use the role or resource, or other Terraform-managed resources still depend on the role or resource.
- Always run `terraform plan` before `terraform apply` and carefully review the changes that will be applied. In many cases, Secrets Manager
  resources may not support in-place updates, in which case they will be replaced. As mentioned, replacing a resource can result in losing other
  relationships and should only be done with caution.

## Security and Configuration
The privileges required to use supported resources and data sources are listed below:

| Resource                  | Required Privileges                                       |
|---------------------------|-----------------------------------------------------------|
| conjur_policy_branch      | create/update on the parent policy                        |
| conjur_host               | create/update on the parent policy                        |
| conjur_group              | create/update on the parent policy                        |
| conjur_secret             | create/update on the parent policy                        |
| conjur_membership         | update on the parent policy of the group                  |
| conjur_permission         | create/update on the parent policy of the resource        |
| conjur_authenticator      | create/update on the `conjur/authn-<authn-type>` policy   |

**Note:** The 'read' privilege is required on managed resources to allow the provider to retrieve the current state and import existing resources.
It is usually granted implicitly assuming the above required privileges have been granted.

| Data Source               | Required Privileges                  |
|---------------------------|--------------------------------------|
| conjur_secret             | execute on the secret                |
| conjur_certificate_issue  | execute on the certificate issuer    |
| conjur_certificate_sign   | execute on the certificate issuer    |

**Note:** The `conjur_secret` data source is also available as an [ephemeral resource](./ephemeral-resources/secret.md) (`ephemeral "conjur_secret"`). 
Ephemeral resources are not stored in Terraform state and are useful when you need secret values during operations but don't want them persisted.

It is recommended to review your use case carefully and adjust the privileges of the provider's host identity to adhere to least-privilege security
principles. This is especially important in environments where other users or systems may have access to the same Secrets Manager resources and
branches. An over-privileged provider could grant access to resources that should not be accessible, modify or delete resources that should not be
modified, or have access to unnecessary secrets - all of which create security risks.

We recommend the following best practices to mitigate security risks and privilege sprawl:
- Consider creating a dedicated policy branch owned by the Terraform provider's host identity under which all Terraform-managed resources are created.
- If using the conjur_secret data source or resource, the `value` attribute is sensitive will be excluded from any logs and CLI output. However it is
  still stored in the Terraform state file. Ensure your sensitive data and state files are securely managed [per Terraform's recommendations](https://www.terraform.io/docs/state/sensitive-data.html).

## Alternate Workflow with Summon

If this Terraform provider does not fit your needs, you can also use
[summon](https://github.com/cyberark/summon) with the
[summon-conjur](https://github.com/cyberark/summon-conjur) provider
to provide secrets to Terraform via environment variables.
The user running `terraform` must already be authenticated with CyberArk Secrets Manager.

Terraform's [`TF_VAR_name` syntax](https://www.terraform.io/docs/configuration/environment-variables.html#tf_var_name)
allows a user to set Terraform variables via environment variables.
To use Terraform with Summon, prefix the environment variable names in secrets.yml with `TF_VAR_`.

### Example

```terraform
# variables.tf
variable "access_key" {}
variable "secret_key" {}
```

```yaml
# secrets.yml
TF_VAR_access_key: !var aws/dev/sys_powerful/access_key_id
TF_VAR_secret_key: !var aws/dev/sys_powerful/secret_access_key
```

Run Terraform with Summon:

```sh-session
$ summon terraform apply
```