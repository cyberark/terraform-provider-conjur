#!/bin/bash
set -eo pipefail

source "$(git rev-parse --show-toplevel)/bin/utils.sh"

# Note - this script must be executed from the main script (bin/test) so the environment is pre-configured
function main() {
  generate_random_values
  docker_compose up -d terraform

  echo ">> Testing provider with tf-included vars"

  declare -a test_results=()

  # Run CRUD tests for each resource and collect results
  echo ">> Running Authenticator CRUD test"
  test_resource_crud "tests/resources/authenticator" "authenticator" "name" "jwt:$TF_VAR_conjur_authenticator_name"
  test_results+=("Authenticator|$?")

  echo ">> Running Group CRUD test"
  test_resource_crud "tests/resources/group" "group" "name"
  test_results+=("Group|$?")

  echo ">> Running Group Membership CRUD test"
  test_resource_crud "tests/resources/membership" "membership" "id" "data/terraform/consumers:host:data/terraform/test/test-workload"
  test_results+=("GroupMember|$?")

  echo ">> Running Permission CRUD test"
  test_resource_crud "tests/resources/permission" "permission" "role_name" "host/data/terraform/test/test-workload:variable/data/terraform/test/workload-secret"
  test_results+=("Permission|$?")

  echo ">> Running Policy Branch CRUD test"
  test_resource_crud "tests/resources/policy_branch" "policy_branch" "full_id" "data/terraform/$TF_VAR_conjur_policy_branch_name"
  test_results+=("PolicyBranch|$?")


  # Workloads API and Static Secrets API are only available in Secrets Manager SaaS (currently)
  if [[ "$TARGET" == "cloud" ]]; then
    echo ">> Running Host CRUD test"
    test_resource_crud "tests/resources/host" "host" "name"
    test_results+=("Host|$?")

    echo ">> Running Secret CRUD test"
    test_resource_crud "tests/resources/secret" "secret" "name" "data/terraform/test/$TF_VAR_conjur_secret_name"
    test_results+=("Secret|$?")
  fi

  # Stop the container
  docker_compose down

  # Report results and set exit code
  report_test_results "${test_results[@]}"
  exit $?
}

function test_resource_crud() {
  local test_dir="$1" # Directory containing create/ and update/ subdirectories
  local resource_name="$2" # Resource name (e.g., "authenticator")
  local id_output_name="$3" # Output variable name for the resource ID
  local import_id="$4"

  echo "Testing ${resource_name} CRUD operations"

  # Cleanup any previous state
  cleanup_terraform "$test_dir"

  # Step 1: Create Resources
  echo "Step 1: Creating ${resource_name}"
  if ! terraform_exec "cd $test_dir/create && \
    terraform init && \
    terraform validate && \
    terraform plan && \
    terraform apply -auto-approve"; then
    echo "FAILED: ${resource_name} creation failed"
    return 1
  fi

  # Get the resource ID for validation
  resource_id=$(terraform_exec "cd $test_dir/create && jq -r '.outputs.${resource_name}_${id_output_name}.value' terraform.tfstate")
  if [[ -z "$resource_id" || "$resource_id" == "null" ]]; then
    echo "FAILED: Could not get $id_output_name from terraform output"
    return 1
  fi
  echo "Created ${resource_name} with ID: $resource_id"


  # Step 2: Import the Resource
  # Skipping import test if no import ID provided (i.e. import not supported)
  if [[ -z "$import_id" ]]; then
    echo "Skipping import for ${resource_name} (no import ID provided). Copying state file to update/ directory."
    rsync -av --exclude='main.tf' "$test_dir/create/" "$test_dir/update/"
  else
    echo "Step 2: Importing ${resource_name}"
    if ! terraform_exec "cd $test_dir/update && \
      terraform init && \
      terraform import conjur_${resource_name}.imported $import_id"; then
      echo "FAILED: ${resource_name} import command failed"
      return 1
    fi

    # Basic validation that the new state file includes the expected resource
    echo "Verifying import of ${resource_name}"
    if ! grep -q "$resource_id" "$test_dir/update/terraform.tfstate"; then
      echo "FAILED: ${resource_name} import verification failed (missing $resource_id)"
      return 1
    fi
    echo "${resource_name} import successful"
    
    # For secret resource, also import the write-only resource, and ensure the secret value was not stored in the state
    if [[ "$resource_name" == "secret" ]]; then
      echo "Step 2: Importing ${resource_name} resource with write-only attribute"
      if ! terraform_exec "cd $test_dir/update && \
        terraform init && \
        terraform import conjur_${resource_name}.imported_wo $import_id-wo"; then
        echo "FAILED: ${resource_name} write-only import command failed"
        return 1
      fi
      
      # Verify that value_wo and value is NOT retrieved/stored in TF state when import succeeds
      echo "Verifying write-only attribute is not stored in state"
      value_wo_in_state=$(terraform_exec "cd $test_dir/update && \
        jq -r '.resources[] | select(.type == \"conjur_secret\" and .name == \"imported_wo\") | .instances[0].attributes.value_wo // \"null\"' terraform.tfstate")
      value_in_state=$(terraform_exec "cd $test_dir/update && \
        jq -r '.resources[] | select(.type == \"conjur_secret\" and .name == \"imported_wo\") | .instances[0].attributes.value // \"null\"' terraform.tfstate")
      
       if [[ ("$value_wo_in_state" != "null" && "$value_wo_in_state" != "") || ("$value_in_state" != "null" && "$value_in_state" != "") ]]; then
         echo "FAILED: value_wo or value should not be stored in state (write-only attribute), but found value_wo='$value_wo_in_state', value='$value_in_state'"
         return 1
       fi
      
      # Verify name exists as a sanity check that import succeeded and the above checks are valid
      name=$(terraform_exec "cd $test_dir/update && \
        jq -r '.resources[] | select(.type == \"conjur_secret\" and .name == \"imported_wo\") | .instances[0].attributes.name // \"null\"' terraform.tfstate")
      
      if [[ "$name" == "null" || "$name" == "" ]]; then
        echo "FAILED: name should be present in state for imported write-only $resource_name resource"
        return 1
      fi
    fi
  fi

  # Step 3: Update the Resource
  if ! terraform_exec "cd $test_dir/update && \
    terraform validate && \
    terraform plan && \
    terraform apply -auto-approve"; then
    echo "FAILED: ${resource_name} update command failed"
    return 1
  fi

  # Verify update was successful
  update_status=$(terraform_exec "cd $test_dir/update && jq -r '.outputs.update_status.value // \"fail\"' terraform.tfstate")
  if [[ "$update_status" != "success" ]]; then
    echo "FAILED: ${resource_name} update verification failed with status: $update_status"
    return 1
  fi

  # Step 4: Delete the Resource
  echo "Step 4: Deleting ${resource_name}"
  if ! terraform_exec "cd $test_dir/update && terraform destroy -auto-approve"; then
    echo "FAILED: ${resource_name} deletion failed"
    return 1
  fi

  echo "SUCCESS: ${resource_name} CRUD testing completed successfully"
  return 0
}

# Generate unique IDs for each run to avoid conflicts
# NOTE: When adding a new TF Var here it also must be copied to the 'terraform' container
# env variables in docker-compose.yml
function generate_random_values() {
  rand_suffix=$(openssl rand -hex 6)
  export TF_VAR_conjur_authenticator_name="tf-auth-$rand_suffix"
  export TF_VAR_conjur_host_name="tf-host-$rand_suffix"
  export TF_VAR_conjur_group_name="tf-group-$rand_suffix"
  export TF_VAR_conjur_secret_name="tf-secret-$rand_suffix"
  export TF_VAR_conjur_policy_branch_name="tf-branch-$rand_suffix"
}

function cleanup_terraform() {
  local test_dir="$1"
  terraform_exec "cd $test_dir/create && rm -rf .terraform* terraform.tfstate*"
  terraform_exec "cd $test_dir/update && rm -rf .terraform* terraform.tfstate*"
}

function report_test_results() {
  echo "=========================================="
  echo "      RESOURCE TEST RESULTS SUMMARY       "
  echo "=========================================="

  local results=("$@")
  local total_tests=${#results[@]}
  local passed_tests=0
  local failed_tests=0

  # Print each test result
  for result in "${results[@]}"; do
    IFS='|' read -r name status <<< "$result"
    if [[ "$status" -eq 0 ]]; then
      echo "✅ $name: PASSED"
      passed_tests=$((passed_tests+1))
    else
      echo "❌ $name: FAILED"
      failed_tests=$((failed_tests+1))
    fi
  done

  echo "=========================================="
  echo "SUMMARY: $passed_tests of $total_tests resource tests passed, $failed_tests failed"
  echo "=========================================="

  if [[ "$passed_tests" -eq "$total_tests" ]]; then
    return 0
  else
    return 1
  fi
}

main
